### Trie

* 字典树是一个非典型多叉树，多叉即每个节点的分支可能有多个
而非典型是指他和一般的多叉树定义有些不同，一般多叉树定义为
```
struct TreeNode
{
    ValueType value;  //节点值
    vector<TreeNode*> child;  //指向子节点
};
```

而字典树的定义是
```
struct TreeNode 
{
    bool isEnd;  //该节点是否是一个串结尾
    TreeNode* next[26];   //字母映射表
};
```
通过以上介绍和代码实现我们可以总结出 Trie 的几点性质：

Trie 的形状和单词的插入或删除顺序无关，也就是说对于任意给定的一组单词，Trie 的形状都是唯一的。

查找或插入一个长度为 L 的单词，访问 next 数组的次数最多为 L+1，和 Trie 中包含多少个单词无关。

Trie 的每个结点中都保留着一个字母表，这是很耗费空间的。如果 Trie 的高度为 n，字母表的大小为 m，最坏的情况是 Trie 中还不存在前缀相同的单词，那空间复杂度就为 O(m^n)。

最后，关于 Trie 的应用场景，希望你能记住 8 个字：一次建树，多次查询


